// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: user_subscription.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const activateSubscription = `-- name: ActivateSubscription :exec
UPDATE "user_subscription"
SET active = true,
    latest_transaction_id = $3,
    subscription_start_date = $4,
    subscription_end_date = $5,
    updated_at = now()
WHERE user_id = $1
    AND moniest_id = $2
`

type ActivateSubscriptionParams struct {
	UserID                string         `json:"user_id"`
	MoniestID             string         `json:"moniest_id"`
	LatestTransactionID   sql.NullString `json:"latest_transaction_id"`
	SubscriptionStartDate time.Time      `json:"subscription_start_date"`
	SubscriptionEndDate   time.Time      `json:"subscription_end_date"`
}

func (q *Queries) ActivateSubscription(ctx context.Context, arg ActivateSubscriptionParams) error {
	_, err := q.db.ExecContext(ctx, activateSubscription,
		arg.UserID,
		arg.MoniestID,
		arg.LatestTransactionID,
		arg.SubscriptionStartDate,
		arg.SubscriptionEndDate,
	)
	return err
}

const checkSubscriptionByMoniestUsername = `-- name: CheckSubscriptionByMoniestUsername :one
SELECT COUNT(*) != 0 AS subscribed
FROM "user_subscription"
    INNER JOIN "moniest" ON "moniest"."id" = "user_subscription"."moniest_id"
    INNER JOIN "user" ON "user"."id" = "moniest"."user_id"
    AND "user"."username" = $2
WHERE "user_subscription"."active" = TRUE
    AND "user_subscription"."user_id" = $1
`

type CheckSubscriptionByMoniestUsernameParams struct {
	UserID   string `json:"user_id"`
	Username string `json:"username"`
}

func (q *Queries) CheckSubscriptionByMoniestUsername(ctx context.Context, arg CheckSubscriptionByMoniestUsernameParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkSubscriptionByMoniestUsername, arg.UserID, arg.Username)
	var subscribed bool
	err := row.Scan(&subscribed)
	return subscribed, err
}

const createSubscription = `-- name: CreateSubscription :one
INSERT INTO "user_subscription" (
        id,
        user_id,
        moniest_id,
        latest_transaction_id,
        subscription_start_date,
        subscription_end_date,
        created_at,
        updated_at
    )
VALUES ($1, $2, $3, $4, $5, $6, now(), now())
RETURNING id, user_id, moniest_id, active, latest_transaction_id, subscription_start_date, subscription_end_date, created_at, updated_at
`

type CreateSubscriptionParams struct {
	ID                    string         `json:"id"`
	UserID                string         `json:"user_id"`
	MoniestID             string         `json:"moniest_id"`
	LatestTransactionID   sql.NullString `json:"latest_transaction_id"`
	SubscriptionStartDate time.Time      `json:"subscription_start_date"`
	SubscriptionEndDate   time.Time      `json:"subscription_end_date"`
}

func (q *Queries) CreateSubscription(ctx context.Context, arg CreateSubscriptionParams) (UserSubscription, error) {
	row := q.db.QueryRowContext(ctx, createSubscription,
		arg.ID,
		arg.UserID,
		arg.MoniestID,
		arg.LatestTransactionID,
		arg.SubscriptionStartDate,
		arg.SubscriptionEndDate,
	)
	var i UserSubscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MoniestID,
		&i.Active,
		&i.LatestTransactionID,
		&i.SubscriptionStartDate,
		&i.SubscriptionEndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const endsubscription = `-- name: Endsubscription :exec
UPDATE "user_subscription"
SET active = false,
    updated_at = now()
WHERE user_id = $1
    AND moniest_id = $2
`

type EndsubscriptionParams struct {
	UserID    string `json:"user_id"`
	MoniestID string `json:"moniest_id"`
}

func (q *Queries) Endsubscription(ctx context.Context, arg EndsubscriptionParams) error {
	_, err := q.db.ExecContext(ctx, endsubscription, arg.UserID, arg.MoniestID)
	return err
}

const getSubscribers = `-- name: GetSubscribers :many
SELECT "u"."id",
    "m"."id" as "moniest_id",
    "u"."fullname",
    "u"."username",
    "u"."email_verified",
    "u"."location",
    "u"."created_at",
    "u"."updated_at",
    "m"."bio",
    "m"."description",
    "m"."score",
    "msi"."id" as "moniest_subscription_info_id",
    "msi"."fee",
    "msi"."message",
    "msi"."updated_at" as "moniest_subscription_info_updated_at",
    COALESCE (
        (
            SELECT "image"."link"
            FROM "image"
            WHERE "image"."user_id" = "u"."id"
                AND "image"."type" = 'profile_photo'
        ),
        ''
    ) AS "profile_photo_link",
    COALESCE (
        (
            SELECT "image"."thumbnail_link"
            FROM "image"
            WHERE "image"."user_id" = "u"."id"
                AND "image"."type" = 'profile_photo'
        ),
        ''
    ) AS "profile_photo_thumbnail_link",
    COALESCE (
        (
            SELECT "image"."link"
            FROM "image"
            WHERE "image"."user_id" = "u"."id"
                AND "image"."type" = 'background_photo'
        ),
        ''
    ) AS "background_photo_link",
    COALESCE (
        (
            SELECT "image"."thumbnail_link"
            FROM "image"
            WHERE "image"."user_id" = "u"."id"
                AND "image"."type" = 'background_photo'
        ),
        ''
    ) AS "background_photo_thumbnail_link"
FROM "user" as u
    INNER JOIN "user_subscription" as us ON "us"."user_id" = "u"."id"
    AND "us"."active" = TRUE
    LEFT JOIN "moniest" as m ON "m"."user_id" = "u"."id"
    LEFT JOIN "moniest_subscription_info" as msi ON "msi"."moniest_id" = "m"."id"
WHERE "us"."moniest_id" = $1
LIMIT $2 OFFSET $3
`

type GetSubscribersParams struct {
	MoniestID string `json:"moniest_id"`
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
}

type GetSubscribersRow struct {
	ID                               string          `json:"id"`
	MoniestID                        sql.NullString  `json:"moniest_id"`
	Fullname                         string          `json:"fullname"`
	Username                         string          `json:"username"`
	EmailVerified                    bool            `json:"email_verified"`
	Location                         sql.NullString  `json:"location"`
	CreatedAt                        time.Time       `json:"created_at"`
	UpdatedAt                        time.Time       `json:"updated_at"`
	Bio                              sql.NullString  `json:"bio"`
	Description                      sql.NullString  `json:"description"`
	Score                            sql.NullFloat64 `json:"score"`
	MoniestSubscriptionInfoID        sql.NullString  `json:"moniest_subscription_info_id"`
	Fee                              sql.NullFloat64 `json:"fee"`
	Message                          sql.NullString  `json:"message"`
	MoniestSubscriptionInfoUpdatedAt sql.NullTime    `json:"moniest_subscription_info_updated_at"`
	ProfilePhotoLink                 interface{}     `json:"profile_photo_link"`
	ProfilePhotoThumbnailLink        interface{}     `json:"profile_photo_thumbnail_link"`
	BackgroundPhotoLink              interface{}     `json:"background_photo_link"`
	BackgroundPhotoThumbnailLink     interface{}     `json:"background_photo_thumbnail_link"`
}

func (q *Queries) GetSubscribers(ctx context.Context, arg GetSubscribersParams) ([]GetSubscribersRow, error) {
	rows, err := q.db.QueryContext(ctx, getSubscribers, arg.MoniestID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSubscribersRow{}
	for rows.Next() {
		var i GetSubscribersRow
		if err := rows.Scan(
			&i.ID,
			&i.MoniestID,
			&i.Fullname,
			&i.Username,
			&i.EmailVerified,
			&i.Location,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Bio,
			&i.Description,
			&i.Score,
			&i.MoniestSubscriptionInfoID,
			&i.Fee,
			&i.Message,
			&i.MoniestSubscriptionInfoUpdatedAt,
			&i.ProfilePhotoLink,
			&i.ProfilePhotoThumbnailLink,
			&i.BackgroundPhotoLink,
			&i.BackgroundPhotoThumbnailLink,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubscribersBriefs = `-- name: GetSubscribersBriefs :many
SELECT "u"."id",
    "u"."fullname",
    "u"."username",
    "u"."email",
    "u"."language"
FROM "user" as u
    INNER JOIN "user_subscription" as us ON "us"."user_id" = "u"."id"
    AND "us"."active" = TRUE
WHERE "us"."moniest_id" = $1
`

type GetSubscribersBriefsRow struct {
	ID       string       `json:"id"`
	Fullname string       `json:"fullname"`
	Username string       `json:"username"`
	Email    string       `json:"email"`
	Language UserLanguage `json:"language"`
}

func (q *Queries) GetSubscribersBriefs(ctx context.Context, moniestID string) ([]GetSubscribersBriefsRow, error) {
	rows, err := q.db.QueryContext(ctx, getSubscribersBriefs, moniestID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSubscribersBriefsRow{}
	for rows.Next() {
		var i GetSubscribersBriefsRow
		if err := rows.Scan(
			&i.ID,
			&i.Fullname,
			&i.Username,
			&i.Email,
			&i.Language,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubscription = `-- name: GetSubscription :one
SELECT id, user_id, moniest_id, active, latest_transaction_id, subscription_start_date, subscription_end_date, created_at, updated_at
FROM "user_subscription"
WHERE user_id = $1
    AND moniest_id = $2
`

type GetSubscriptionParams struct {
	UserID    string `json:"user_id"`
	MoniestID string `json:"moniest_id"`
}

func (q *Queries) GetSubscription(ctx context.Context, arg GetSubscriptionParams) (UserSubscription, error) {
	row := q.db.QueryRowContext(ctx, getSubscription, arg.UserID, arg.MoniestID)
	var i UserSubscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MoniestID,
		&i.Active,
		&i.LatestTransactionID,
		&i.SubscriptionStartDate,
		&i.SubscriptionEndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserSubscriptionInfo = `-- name: GetUserSubscriptionInfo :one
SELECT "user"."id" as "user_id",
    "moniest"."id" as "moniest_id",
    "user_subscription"."latest_transaction_id" as "transaction_id",
    "user_subscription"."subscription_start_date",
    "user_subscription"."subscription_end_date",
    "binance_payout_history"."payer_id",
    "binance_payout_history"."amount"
FROM "user_subscription"
    INNER JOIN "moniest" ON "moniest"."id" = "user_subscription"."moniest_id"
    INNER JOIN "user" ON "user"."id" = "moniest"."user_id"
    INNER JOIN "binance_payout_history" ON "binance_payout_history"."transaction_id" = "user_subscription"."latest_transaction_id"
    AND "binance_payout_history"."date_index" = 1
    AND "user"."username" = $2
WHERE "user_subscription"."active" = TRUE
    AND "user_subscription"."user_id" = $1
`

type GetUserSubscriptionInfoParams struct {
	UserID   string `json:"user_id"`
	Username string `json:"username"`
}

type GetUserSubscriptionInfoRow struct {
	UserID                string         `json:"user_id"`
	MoniestID             string         `json:"moniest_id"`
	TransactionID         sql.NullString `json:"transaction_id"`
	SubscriptionStartDate time.Time      `json:"subscription_start_date"`
	SubscriptionEndDate   time.Time      `json:"subscription_end_date"`
	PayerID               string         `json:"payer_id"`
	Amount                float64        `json:"amount"`
}

func (q *Queries) GetUserSubscriptionInfo(ctx context.Context, arg GetUserSubscriptionInfoParams) (GetUserSubscriptionInfoRow, error) {
	row := q.db.QueryRowContext(ctx, getUserSubscriptionInfo, arg.UserID, arg.Username)
	var i GetUserSubscriptionInfoRow
	err := row.Scan(
		&i.UserID,
		&i.MoniestID,
		&i.TransactionID,
		&i.SubscriptionStartDate,
		&i.SubscriptionEndDate,
		&i.PayerID,
		&i.Amount,
	)
	return i, err
}
