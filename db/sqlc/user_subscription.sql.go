// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: user_subscription.sql

package db

import (
	"context"
)

const activateSubscription = `-- name: ActivateSubscription :exec
UPDATE "user_subscription"
SET active = true
WHERE user_id = $1
    AND moniest_id = $2
`

type ActivateSubscriptionParams struct {
	UserID    string `json:"user_id"`
	MoniestID string `json:"moniest_id"`
}

func (q *Queries) ActivateSubscription(ctx context.Context, arg ActivateSubscriptionParams) error {
	_, err := q.db.ExecContext(ctx, activateSubscription, arg.UserID, arg.MoniestID)
	return err
}

const checkSubscriptionByMoniestUsername = `-- name: CheckSubscriptionByMoniestUsername :one
SELECT COUNT(*) != 0 AS subscribed
FROM "user_subscription"
    INNER JOIN "moniest" ON "moniest"."id" = "user_subscription"."moniest_id"
    INNER JOIN "user" ON "user"."id" = "moniest"."user_id"
    AND "user"."username" = $2
WHERE "user_subscription"."user_id" = $1
`

type CheckSubscriptionByMoniestUsernameParams struct {
	UserID   string `json:"user_id"`
	Username string `json:"username"`
}

func (q *Queries) CheckSubscriptionByMoniestUsername(ctx context.Context, arg CheckSubscriptionByMoniestUsernameParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkSubscriptionByMoniestUsername, arg.UserID, arg.Username)
	var subscribed bool
	err := row.Scan(&subscribed)
	return subscribed, err
}

const createSubscription = `-- name: CreateSubscription :one
INSERT INTO "user_subscription" (
        id,
        user_id,
        moniest_id,
        created_at,
        updated_at
    )
VALUES ($1, $2, $3, now(), now())
RETURNING id, user_id, moniest_id, active, created_at, updated_at
`

type CreateSubscriptionParams struct {
	ID        string `json:"id"`
	UserID    string `json:"user_id"`
	MoniestID string `json:"moniest_id"`
}

func (q *Queries) CreateSubscription(ctx context.Context, arg CreateSubscriptionParams) (UserSubscription, error) {
	row := q.db.QueryRowContext(ctx, createSubscription, arg.ID, arg.UserID, arg.MoniestID)
	var i UserSubscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MoniestID,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const endsubscription = `-- name: Endsubscription :exec
UPDATE "user_subscription"
SET active = false,
    updated_at = now()
WHERE user_id = $1
    AND moniest_id = $2
`

type EndsubscriptionParams struct {
	UserID    string `json:"user_id"`
	MoniestID string `json:"moniest_id"`
}

func (q *Queries) Endsubscription(ctx context.Context, arg EndsubscriptionParams) error {
	_, err := q.db.ExecContext(ctx, endsubscription, arg.UserID, arg.MoniestID)
	return err
}

const getSubscription = `-- name: GetSubscription :one
SELECT id, user_id, moniest_id, active, created_at, updated_at
FROM "user_subscription"
WHERE user_id = $1
    AND moniest_id = $2
`

type GetSubscriptionParams struct {
	UserID    string `json:"user_id"`
	MoniestID string `json:"moniest_id"`
}

func (q *Queries) GetSubscription(ctx context.Context, arg GetSubscriptionParams) (UserSubscription, error) {
	row := q.db.QueryRowContext(ctx, getSubscription, arg.UserID, arg.MoniestID)
	var i UserSubscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MoniestID,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
